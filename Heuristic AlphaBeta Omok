import math


def print_board(board):
    print(" ", end=" ")
    for i in range(len(board)):
        print(chr(ord('a') + i), end=" ")
    print()
    for i in range(len(board)):
        print(i + 1, end="")
        if i < 9:
            print(end=" ")
        for j in range(len(board[i])):
            print(board[i][j], end=" ")
        print()


def place_stone(board, row, col, stone):
    if board[row][col] == ' ':
        board[row][col] = stone
        return True
    else:
        print("이미 둔 자리입니다!")
        return False


def check_winner(board, stone):
    directions = [(0, 1), (1, 0), (1, 1), (1, -1)]
    for row in range(len(board)):
        for col in range(len(board[row])):
            if board[row][col] == stone:
                for d in directions:
                    count = 1
                    for i in range(1, 5):
                        if 0 <= row + d[0] * i < len(board) and 0 <= col + d[1] * i < len(board[row]):
                            if board[row + d[0] * i][col + d[1] * i] == stone:
                                count += 1
                            else:
                                break
                        else:
                            break
                    if count >= 5:
                        return True
    return False


def omok_game(size=19):
    board = [[' ' for _ in range(size)] for _ in range(size)]
    stone = 'X'  # 플레이어가 선공이 되도록 설정
    while True:
        stone = 'X'
        print_board(board)
        print(f"{stone}의 차례입니다")

        move = input("착수할 곳을 입력해주세요(e.g., 'a3'): ")

        if len(move) >= 2 and move[0].isalpha() and move[1:].isdigit():
            alpha = move[0]
            digit = move[1:]
            col = ord(alpha) - ord('a')
            row = int(digit) - 1
            if 0 <= row < size and 0 <= col < size:
                if place_stone(board, row, col, stone):
                    if check_winner(board, stone):
                        print_board(board)
                        print(f"경기 종료. {stone}가 승리했습니다.")
                        break
                    stone = 'O'  # 플레이어가 수를 둔 후엔 AI의 차례로 변경
                    _, i, j = alpha_beta(board, stone, 2, -math.inf, math.inf, True)  # AI의 수를 계산
                    if place_stone(board, i, j, stone):
                        if check_winner(board, stone):
                            print_board(board)
                            print(f"경기 종료. {stone}가 승리했습니다.")
                            break
            else:
                print("바둑판 범위 밖입니다.")
        else:
            print("착수할 곳의 입력값이 올바르지 않습니다.")


def alpha_beta(board, turn, depth, alpha, beta, maximizing_player):
    if depth == 0 or check_winner(board, 'X') or check_winner(board, 'O'):
        # 게임이 종료되었거나 최대 탐색 깊이에 도달한 경우에는 휴리스틱을 계산하여 반환합니다.
        # print(heuristic(board,turn))
        return heuristic(board, turn), None, None

    best_row = None
    best_col = None

    if maximizing_player:
        value = -math.inf
        for move in possible_moves(board):
            # 보드에 수를 둡니다.
            place_stone(board, move[0], move[1], 'O')
            child_value, _, _ = alpha_beta(board, 'O', depth - 1, alpha, beta, False)
            # 보드에서 수를 제거합니다.
            board[move[0]][move[1]] = ' '
            if child_value > value:
                value = child_value
                best_row = move[0]
                best_col = move[1]
            alpha = max(alpha, child_value)
            if alpha >= beta:
                break  # return value, best_row, best_col
        return value, best_row, best_col
    else:
        value = math.inf
        for move in possible_moves(board):
            place_stone(board, move[0], move[1], 'X')
            child_value, _, _ = alpha_beta(board, 'X', depth - 1, alpha, beta, True)
            # print_board(board)
            # print(child_value)
            board[move[0]][move[1]] = ' '
            if child_value < value:
                value = child_value
                best_row = move[0]
                best_col = move[1]
            beta = min(beta, child_value)
            if beta <= alpha:
                break  # return value, best_row, best_col
        return value, best_row, best_col


def possible_moves(board):
    moves = []
    for i in range(len(board)):
        for j in range(len(board[i])):
            if board[i][j] == ' ':
                # 주변에 상대 혹은 나의 돌이 있는 경우에만 해당 위치를 추가합니다.
                if has_adjacent_stone(board, i, j):
                    moves.append((i, j))

    return moves


def has_adjacent_stone(board, row, col):
    # 상대 혹은 나의 돌인지 확인합니다.
    stone = board[row][col]

    # 인접한 위치들을 검사합니다.
    for dr in [-1, 0, 1]:
        for dc in [-1, 0, 1]:
            if dr == 0 and dc == 0:
                continue  # 현재 위치는 제외합니다.
            r = row + dr
            c = col + dc
            if 0 <= r < len(board) and 0 <= c < len(board[r]) and (board[r][c] == 'O' or board[r][c] == 'X'):
                return True  # 주변에 상대 혹은 나의 돌이 있는 경우 True를 반환합니다.
    return False  # 주변에 상대 혹은 나의 돌이 없는 경우 False를 반환합니다.


def heuristic(board, turn):
    my_stone = 'O'
    opponent_stone = 'X'
    my_score = measure(board, my_stone)
    op_score = measure(board, opponent_stone)

    return my_score - op_score


def measure(board, stone):
    op = 'O' if stone == 'X' else 'X'
    my = stone
    score = 0
    result=[]
    for i in range(len(board)):
        for j in range(len(board)):

            if j <= len(board[i]) - 4:
                score=0
                count = 1
                while j + count < len(board[i]) and board[i][j + count] == my:
                    count += 1
                if count >= 2:
                    score += count ** 2
                    left_block = 0
                    right_block = 0
                    if j > 0 and board[i][j - 1] == op:
                        left_block += 1
                    if j + count < len(board[i]) and board[i][j + count] == op:
                        right_block += 1
                    if left_block and right_block == 2:
                        score *= 0
                    elif left_block == 1 or right_block == 1:
                        score *= 1
                    else:
                        score *= 2
                    result.append(score)

            if i <= len(board) - 4:
                score = 0
                count = 1
                while i + count < len(board) and board[i + count][j] == my:
                    count += 1
                if count >= 2:
                    score += count ** 2
                    up_block = 0
                    down_block = 0
                    if i > 0 and board[i - 1][j] == op:
                        up_block += 1
                    if i + count < len(board) and board[i + count][j] == op:
                        down_block += 1
                    if up_block == 1 and down_block == 1:
                        score *= 0
                    elif up_block == 1 or down_block == 1:
                        score *= 1
                    else:
                        score *= 2
                    result.append(score)

            if i <= len(board) - 4 and j <= len(board[i]) - 4:
                score = 0
                count = 1
                while i + count < len(board) and j + count < len(board[i]) and board[i + count][
                    j + count] == my:
                    count += 1
                if count >= 2:
                    score += count ** 2
                    left_up_block = 0
                    right_down_block = 0
                    if i > 0 and j > 0 and board[i - 1][j - 1] == op:
                        left_up_block += 1
                    if i + count < len(board) and j + count < len(board[i]) and board[i + count][
                        j + count] == op:
                        right_down_block += 1
                    if left_up_block == 1 and right_down_block == 1:
                        score *= 0
                    elif left_up_block == 1 or right_down_block == 1:
                        score *= 1
                    else:
                        score *= 2
                    result.append(score)

            if i <= len(board) - 4 and j >= 3:
                score = 0
                count = 1
                while i + count < len(board) and j - count >= 0 and board[i + count][j - count] == my:
                    count += 1
                if count >= 2:
                    score += count ** 2
                    right_up_block = 0
                    left_down_block = 0
                    if i > 0 and j < len(board[i]) - 1 and board[i - 1][j + 1] == op:
                        right_up_block += 1
                    if i + count < len(board) and j - count >= 0 and board[i + count][j - count] == op:
                        left_down_block += 1
                    if right_up_block == 1 and left_down_block == 1:
                        score *= 0
                    elif right_up_block == 1 or left_down_block == 1:
                        score *= 1
                    else:
                        score *= 2
                    result.append(score)
    return max(result)


omok_game()
